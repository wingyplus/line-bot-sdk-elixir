# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2026 Thanabodee Charoenpiriyakij

# NOTE: This file is auto generated by OpenAPI Generator unset (https://openapi-generator.tech).
# Do not edit this file manually.

defmodule LINE.Bot.ChannelAccessToken do
  @moduledoc """
  API calls for all endpoints tagged `ChannelAccessToken`.
  """

  alias LINE.Bot.Deserializer

  @doc """
  Gets all valid channel access token key IDs.

  ### Parameters

  - `client` (`t:Req.Request.t/0`): Client to make request with
  - `client_assertion_type` (`t:String.t/0`): `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`
  - `client_assertion` (`t:String.t/0`): A JSON Web Token (JWT) (opens new window)the client needs to create and sign with the private key.
  - `client_opts` (`t:keyword/0`): Options to pass to `Req.request`

  ### Returns

  - `{:ok, LINE.Bot.Model.ChannelAccessTokenKeyIdsResponse.t}` on success
  - `{:error, Req.Response.t}` on failure
  """
  def gets_all_valid_channel_access_token_key_ids(
        client,
        client_assertion_type,
        client_assertion,
        client_opts \\ []
      ) do
    request_opts = [
      method: :get,
      url: "/oauth2/v2.1/tokens/kid",
      params:
        Enum.reject(
          [
            {"client_assertion_type", client_assertion_type},
            {"client_assertion", client_assertion}
          ],
          fn {_, v} -> is_nil(v) end
        )
    ]

    client
    |> Req.request(Keyword.merge(request_opts, client_opts))
    |> Deserializer.evaluate_response([
      {200, LINE.Bot.ChannelAccessToken.Model.ChannelAccessTokenKeyIdsResponse}
    ])
  end

  @doc """
  Issue short-lived channel access token

  ### Parameters

  - `client` (`t:Req.Request.t/0`): Client to make request with
  - `grant_type` (`t:String.t/0`): `client_credentials`
  - `client_id` (`t:String.t/0`): Channel ID.
  - `client_secret` (`t:String.t/0`): Channel secret.
  - `client_opts` (`t:keyword/0`): Options to pass to `Req.request`

  ### Returns

  - `{:ok, LINE.Bot.Model.IssueShortLivedChannelAccessTokenResponse.t}` on success
  - `{:error, Req.Response.t}` on failure
  """
  def issue_channel_token(client, grant_type, client_id, client_secret, client_opts \\ []) do
    request_opts = [
      method: :post,
      url: "/v2/oauth/accessToken",
      form:
        Enum.reject(
          [
            {"grant_type", grant_type},
            {"client_id", client_id},
            {"client_secret", client_secret}
          ],
          fn {_, v} -> is_nil(v) end
        )
    ]

    client
    |> Req.request(Keyword.merge(request_opts, client_opts))
    |> Deserializer.evaluate_response([
      {200, LINE.Bot.ChannelAccessToken.Model.IssueShortLivedChannelAccessTokenResponse},
      {400, LINE.Bot.ChannelAccessToken.Model.ErrorResponse}
    ])
  end

  @doc """
  Issues a channel access token that allows you to specify a desired expiration date. This method lets you use JWT assertion for authentication.

  ### Parameters

  - `client` (`t:Req.Request.t/0`): Client to make request with
  - `grant_type` (`t:String.t/0`): client_credentials
  - `client_assertion_type` (`t:String.t/0`): urn:ietf:params:oauth:client-assertion-type:jwt-bearer
  - `client_assertion` (`t:String.t/0`): A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key.
  - `client_opts` (`t:keyword/0`): Options to pass to `Req.request`

  ### Returns

  - `{:ok, LINE.Bot.Model.IssueChannelAccessTokenResponse.t}` on success
  - `{:error, Req.Response.t}` on failure
  """
  def issue_channel_token_by_jwt(
        client,
        grant_type,
        client_assertion_type,
        client_assertion,
        client_opts \\ []
      ) do
    request_opts = [
      method: :post,
      url: "/oauth2/v2.1/token",
      form:
        Enum.reject(
          [
            {"grant_type", grant_type},
            {"client_assertion_type", client_assertion_type},
            {"client_assertion", client_assertion}
          ],
          fn {_, v} -> is_nil(v) end
        )
    ]

    client
    |> Req.request(Keyword.merge(request_opts, client_opts))
    |> Deserializer.evaluate_response([
      {200, LINE.Bot.ChannelAccessToken.Model.IssueChannelAccessTokenResponse}
    ])
  end

  @doc """
  Issues a new stateless channel access token, which doesn't have max active token limit unlike the other token types. The newly issued token is only valid for 15 minutes but can not be revoked until it naturally expires. 

  ### Parameters

  - `client` (`t:Req.Request.t/0`): Client to make request with
  - `optional_args` (keyword): Optional parameters
    - `:grant_type` (`t:String.t/0`): `client_credentials`
    - `:client_assertion_type` (`t:String.t/0`): URL-encoded value of `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`
    - `:client_assertion` (`t:String.t/0`): A JSON Web Token the client needs to create and sign with the private key of the Assertion Signing Key.
    - `:client_id` (`t:String.t/0`): Channel ID.
    - `:client_secret` (`t:String.t/0`): Channel secret.
  - `client_opts` (`t:keyword/0`): Options to pass to `Req.request`

  ### Returns

  - `{:ok, LINE.Bot.Model.IssueStatelessChannelAccessTokenResponse.t}` on success
  - `{:error, Req.Response.t}` on failure
  """
  def issue_stateless_channel_token(client, optional_args \\ [], client_opts \\ []) do
    grant_type = Keyword.get(optional_args, :grant_type)
    client_assertion_type = Keyword.get(optional_args, :client_assertion_type)
    client_assertion = Keyword.get(optional_args, :client_assertion)
    client_id = Keyword.get(optional_args, :client_id)
    client_secret = Keyword.get(optional_args, :client_secret)

    request_opts = [
      method: :post,
      url: "/oauth2/v3/token",
      form:
        Enum.reject(
          [
            {"grant_type", grant_type},
            {"client_assertion_type", client_assertion_type},
            {"client_assertion", client_assertion},
            {"client_id", client_id},
            {"client_secret", client_secret}
          ],
          fn {_, v} -> is_nil(v) end
        )
    ]

    client
    |> Req.request(Keyword.merge(request_opts, client_opts))
    |> Deserializer.evaluate_response([
      {200, LINE.Bot.ChannelAccessToken.Model.IssueStatelessChannelAccessTokenResponse}
    ])
  end

  @doc """
  Revoke short-lived or long-lived channel access token

  ### Parameters

  - `client` (`t:Req.Request.t/0`): Client to make request with
  - `access_token` (`t:String.t/0`): Channel access token
  - `client_opts` (`t:keyword/0`): Options to pass to `Req.request`

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Req.Response.t}` on failure
  """
  def revoke_channel_token(client, access_token, client_opts \\ []) do
    request_opts = [
      method: :post,
      url: "/v2/oauth/revoke",
      form: Enum.reject([{"access_token", access_token}], fn {_, v} -> is_nil(v) end)
    ]

    client
    |> Req.request(Keyword.merge(request_opts, client_opts))
    |> Deserializer.evaluate_response([
      {200, false}
    ])
  end

  @doc """
  Revoke channel access token v2.1

  ### Parameters

  - `client` (`t:Req.Request.t/0`): Client to make request with
  - `client_id` (`t:String.t/0`): Channel ID
  - `client_secret` (`t:String.t/0`): Channel Secret
  - `access_token` (`t:String.t/0`): Channel access token
  - `client_opts` (`t:keyword/0`): Options to pass to `Req.request`

  ### Returns

  - `{:ok, nil}` on success
  - `{:error, Req.Response.t}` on failure
  """
  def revoke_channel_token_by_jwt(
        client,
        client_id,
        client_secret,
        access_token,
        client_opts \\ []
      ) do
    request_opts = [
      method: :post,
      url: "/oauth2/v2.1/revoke",
      form:
        Enum.reject(
          [
            {"client_id", client_id},
            {"client_secret", client_secret},
            {"access_token", access_token}
          ],
          fn {_, v} -> is_nil(v) end
        )
    ]

    client
    |> Req.request(Keyword.merge(request_opts, client_opts))
    |> Deserializer.evaluate_response([
      {200, false}
    ])
  end

  @doc """
  Verify the validity of short-lived and long-lived channel access tokens

  ### Parameters

  - `client` (`t:Req.Request.t/0`): Client to make request with
  - `access_token` (`t:String.t/0`): A short-lived or long-lived channel access token.
  - `client_opts` (`t:keyword/0`): Options to pass to `Req.request`

  ### Returns

  - `{:ok, LINE.Bot.Model.VerifyChannelAccessTokenResponse.t}` on success
  - `{:error, Req.Response.t}` on failure
  """
  def verify_channel_token(client, access_token, client_opts \\ []) do
    request_opts = [
      method: :post,
      url: "/v2/oauth/verify",
      form: Enum.reject([{"access_token", access_token}], fn {_, v} -> is_nil(v) end)
    ]

    client
    |> Req.request(Keyword.merge(request_opts, client_opts))
    |> Deserializer.evaluate_response([
      {200, LINE.Bot.ChannelAccessToken.Model.VerifyChannelAccessTokenResponse}
    ])
  end

  @doc """
  You can verify whether a Channel access token with a user-specified expiration (Channel Access Token v2.1) is valid.

  ### Parameters

  - `client` (`t:Req.Request.t/0`): Client to make request with
  - `access_token` (`t:String.t/0`): Channel access token with a user-specified expiration (Channel Access Token v2.1).
  - `client_opts` (`t:keyword/0`): Options to pass to `Req.request`

  ### Returns

  - `{:ok, LINE.Bot.Model.VerifyChannelAccessTokenResponse.t}` on success
  - `{:error, Req.Response.t}` on failure
  """
  def verify_channel_token_by_jwt(client, access_token, client_opts \\ []) do
    request_opts = [
      method: :get,
      url: "/oauth2/v2.1/verify",
      params: Enum.reject([{"access_token", access_token}], fn {_, v} -> is_nil(v) end)
    ]

    client
    |> Req.request(Keyword.merge(request_opts, client_opts))
    |> Deserializer.evaluate_response([
      {200, LINE.Bot.ChannelAccessToken.Model.VerifyChannelAccessTokenResponse}
    ])
  end
end
